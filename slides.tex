%%%%
% Преамбула: подключение необходимых пакетов
% Редактируйте осторожно!
%

\documentclass[hyperref={unicode}]{beamer}

\usepackage[utf8x]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{color, colortbl}
\usepackage{rotating} 
\usepackage{graphicx}
\usepackage{algorithmic}

\usetheme[nosecheader]{PetrSU-CS}


%%%%
% Преамбула: основные параметры презентации
% Отредактируйте в соответствии с комментариями
%

\title[%
    % Краткое название работы не используется в этой презентации!
    Анализ деков
]{%
    % Полное название работы отображается на титульной странице
    Анализ параллельных реализаций деков
}

% Подзаголовком опишите тип работы:
% - Курсовая работа
% - Выпускная квалификационная работа бакалавра
% - Дипломная работа
% - Магистерская диссертация
\subtitle{Курсовая работа}

\author[%
    % Имя и фамилия автора работы отображаются на каждом слайде в нижнем колонтитуле
    Кучумов Руслан
]{%
    % Имя, отчество и фамилия автора работы отображаются на титульном слайде
    Кучумов Руслан Ильдусович
}

\date[%
    % Дата защиты
    20.05.2015
]{%
    % Руководитель
    Научный руководитель: д.ф.-м.н., профессор А. В. Соколов
}

\institute[%
    % Краткое название организации не используется в этой презентации
    ПетрГУ
]{%
    % Полное название организации и подразделения
    Петрозаводский государственный университет\\
    Кафедра информатики и математического обеспечения
}


%%%%
% Начало содержимого слайдов
%

\begin{document}

% Титульный слайд
\begin{frame}
    \maketitle
\end{frame}

% Пример слайда для обоснования актуальности работы
\begin{frame}
    % Заголовок слайда
    \frametitle{Параллельные вычисления}
     % вообщем, есть программы, котороый можно расппаралеллить разбив
     % на много маленьких подпрограмм (тн задач). Но эти подпрограммы мог быть насктолько мальенькие,
     % что если каждой выделять по потоку, то накладные расходы их создание и
     % и завершение могут превысить вычислительные расходы самой задачи. 

     % И для решения этой пролемы заранее выделяют определенное количество потоков
     % и используют планировщик задач, который распределяет эти задачи между потоками.

     % Планировщик работает на уровне пользоватльского приложения, содержит очереь задач приложения,
     % и назначает задачи из нее для выполенения потоками.

    % цель такого планировщика - как и всех остальных, чтобы потоки, или соотвт им процесоры не простаивали, 
    % без выполнения задач
    Картинка
\end{frame}

% Пример слайда с формулировкой целей и задач
\begin{frame}
    % Чем я занимался: реализовывал планровщик задач, использующий принцип workstealing. 
    % потом подрбнее
    % этот планировщик реализован на С++11, тк во первых он, намного удобнее и имеет больше возможностей
    % по сравению OpenMP.
    
    \frametitle{Цель и задачи}
    \begin{block}{Цель работы}
        Реализация workstealing планировщика задач
    \end{block}
    \begin{block}{Задачи}
        \begin{itemize}
            \item Изучить управление потоками в C++11
            \item Реализовать планировщик задач
        \end{itemize}
    \end{block}
\end{frame}


\begin{frame}
    \frametitle{Планировщик задач}

    % Простой подход для реализации такого планровщика создать огромную очередь задач. И каждый 
    % поток, или рабочий, будет брать и добавлять из нее задачи для выполния. 

    Картинка

    % Проблема естественно тут в возникновении сосотяния гонки при обращении к одному из концов очереди.

\end{frame}

\begin{frame}
    \frametitle{Планировщик задач}

	Картинка

	% Очевидное решение - назначить кадому потоку по очереди задач. Тогда поток будет добавлять задачу в свою 
	% очередь и брать из нее же задачи для выполнения. 
	% И тут всезамечательно, пока у потоков есть задачи для работы. Но, часто случается, так что один поток
	% нагружен, а остальные бездельничают. Нужно, конечно как-то перераспределять задачи между этими потоками.
	% Есть несклько подходов:
	%  -статическое распределение. Когда известны все подробности о задачах и можно заранее просчитать оптимальный
	%   план их выполнения. Поиск такого плана часто является NP полной задачей.
	%   -и динамическое распределение. Когда используется какая-та тривиальная стратегия планирования. Оно не 
	%   такое оптимальное как статическое, но дает приеемдемый результат с низкие накладные расходы.
\end{frame}

\begin{frame}
	\frametitle{Workstealing}
	% Стандартный подход для такого распеределения, это тн воркстилинг. Он испльзуется во многих планировщиках,
	% в расте, силке, джаве и тбб
	% Его суть в том, что когда у птока нет задач для выполнения, то крадет их у другого потока.
	% Конечно, в таком слуяае опять появляются сотояние гонки. Но, чтобы как-то это оптимизировать,
	% вместо очередей используют деки - очередь с двумя концами. И потоку разрешено красть задачи только 
	% из одного конца дека. А другой испльзуется только владелльцем этого дека для добавления и извлечения задач.
\end{frame}


\begin{frame}
    \frametitle{}
    % такие ограничения на дек, позволяют оптимизировать эту структуру данных и сделтаьть ее 
    % во первых лок фрии. во вторых, использовать в качестве контейнера обычный массив.
\end{frame}

\begin{frame}
	\frametitle{чё за лок фри}
	% вместо мьютексов или замков используется атомарные опреации с памятью. А именно сомпаре анд сет.
	% Она сравнивает значение переменной с ожидаемым, и если они совпрадают, то изменяет его на новое.
    % Здесь это испльзуется при измении индексов вершин деков. И если эта операция не завершилась с успехом
    % то это означаеттчо поток проиграл гонку с другим потоком, те уже взял эту задачу.
    % Другми словами, мы изменяем индекс, если никто другой не сделал этого первым

    Код с коментами
\end{frame}

\begin{frame}
	\frametitle{Chase-Lev Деки}
	% Есть несколько реализаиций таких деков. Я использовал работу авторов Чейс-Лев, тк она самая последняя и 
	% наиболее эффективная. 
	% В его основе лежит циклический массив и его свойство, что значения индексов концов дека всегда только 
	% увеличиваются 
	% Например, в отличие от остальных реализаицй - пропадает необходимость сбрасывать эти значения, когда дек 
	% становится пустым.
	% И также, когда обнаруживаем что дек перепонлнен, то мы выделяем новый массив, а значения вершин не изменям. Хотя при 
	% этом индексы элементов этого массива изменяются.
    % Это на самом деле очень важно, так с этими могут работать параелльно несокльо потоков.
\end{frame}

\begin{frame}
	\frametitle{Другие реализации деков}
    % Все началось с работы этих авторов. Все на нее ссылаются как на ABP дек.
    % он испьлзует обычный массив, не циклический. без поддержки динамичесокго измения размера
    % но эта структура локфрии и это реализовано с помощью CAS но для перемнных, ктоорые хранят 
    % количсетво измений индексов вершин, тн stamp

    % Еще одна основанная на двусвязанных списках. Поддерживается динамическое измение размера,
    % но достотчно сложный и накладные расходы на поддрежание списка

    % Есть реализации позоволяющая красть сразу половину всех задач. Это эффективно при расспараллеливании
    % на мнгоо мальких и несвязных задач. Например при работе с графами (поиск в ширину)
\end{frame}

\begin{frame}
    \frametitle{Интерфейс планировщика задач}
\end{frame}

% Пример заключительного слайда
\begin{frame}
    \frametitle{Заключение}
    Получены результаты:

	\begin{itemize}
		\item Изучено управление потоками в C++11
        \item Изучены реализации деков
		\item Реализован планировщик задач, использующий chase-lev дек
	\end{itemize}
\end{frame}

\begin{frame}
    \frametitle{}

    {\Large\mbox{}\hfil Спасибо за внимание!}

\end{frame}
\end{document}
